/// Unit tests for the [NonTrackpadPanGestureRecognizer].
///
/// Tests cover:
/// - Gesture recognizer construction
/// - Pan gesture detection for different pointer types
/// - Mouse vs trackpad differentiation
/// - Gesture configuration options
/// - Event handling behavior
///
/// Note: Flutter's PointerDownEvent and PointerMoveEvent assert that
/// PointerDeviceKind.trackpad is NOT used for these event types. Trackpad
/// gestures use PointerPanZoomStartEvent, PointerPanZoomUpdateEvent, and
/// PointerPanZoomEndEvent instead. This is by design in Flutter.
@Tags(['unit'])
library;

import 'package:flutter/gestures.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:vyuh_node_flow/src/editor/non_trackpad_pan_gesture_recognizer.dart';

/// A test-only subclass that exposes protected methods for verification.
class TestableNonTrackpadPanGestureRecognizer
    extends NonTrackpadPanGestureRecognizer {
  TestableNonTrackpadPanGestureRecognizer({super.debugOwner});

  /// Exposes isPointerAllowed for testing purposes.
  bool testIsPointerAllowed(PointerEvent event) => isPointerAllowed(event);

  /// Exposes handleNonAllowedPointer for testing purposes.
  void testHandleNonAllowedPointer(PointerDownEvent event) =>
      handleNonAllowedPointer(event);
}

void main() {
  group('NonTrackpadPanGestureRecognizer Construction', () {
    test('creates recognizer without debug owner', () {
      final recognizer = NonTrackpadPanGestureRecognizer();

      expect(recognizer, isNotNull);
      expect(recognizer.debugOwner, isNull);

      recognizer.dispose();
    });

    test('creates recognizer with debug owner', () {
      const owner = 'TestOwner';
      final recognizer = NonTrackpadPanGestureRecognizer(debugOwner: owner);

      expect(recognizer, isNotNull);
      expect(recognizer.debugOwner, equals(owner));

      recognizer.dispose();
    });

    test('inherits from PanGestureRecognizer', () {
      final recognizer = NonTrackpadPanGestureRecognizer();

      expect(recognizer, isA<PanGestureRecognizer>());

      recognizer.dispose();
    });
  });

  group('Pointer Device Kind Filtering via PointerPanZoom Events', () {
    // PointerPanZoomStartEvent is the correct event type for trackpad gestures.
    // Flutter does not allow PointerDownEvent with trackpad kind.

    test('addPointerPanZoom filters based on event kind property', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // PointerPanZoomStartEvent is typically generated by trackpads
      // The default kind for PointerPanZoomStartEvent is trackpad
      final panZoomEvent = PointerPanZoomStartEvent(
        pointer: 1,
        position: const Offset(100, 100),
        embedderId: 0,
      );

      // Verify the event has trackpad kind (default for PointerPanZoomStartEvent)
      expect(panZoomEvent.kind, equals(PointerDeviceKind.trackpad));

      // Should not throw - returns early for trackpad
      expect(() => recognizer.addPointerPanZoom(panZoomEvent), returnsNormally);
    });

    test('handleEvent ignores trackpad-kind events', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // PointerPanZoomUpdateEvent also has trackpad kind by default
      final panZoomUpdateEvent = PointerPanZoomUpdateEvent(
        pointer: 1,
        position: const Offset(150, 150),
        pan: const Offset(50, 50),
        panDelta: const Offset(10, 10),
        scale: 1.0,
        rotation: 0.0,
      );

      expect(panZoomUpdateEvent.kind, equals(PointerDeviceKind.trackpad));

      // Should not throw - returns early for trackpad
      expect(() => recognizer.handleEvent(panZoomUpdateEvent), returnsNormally);
    });
  });

  group('Mouse and Touch Event Handling', () {
    test('allows mouse pointer down events', () {
      final recognizer = TestableNonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final mouseEvent = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.mouse,
      );

      // Mouse events should be allowed by our recognizer
      // Note: super.isPointerAllowed also checks other conditions
      // such as whether the correct buttons are pressed
      expect(mouseEvent.kind, equals(PointerDeviceKind.mouse));
    });

    test('allows touch pointer down events', () {
      final recognizer = TestableNonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final touchEvent = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.touch,
      );

      expect(touchEvent.kind, equals(PointerDeviceKind.touch));
    });

    test('allows stylus pointer down events', () {
      final recognizer = TestableNonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final stylusEvent = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.stylus,
      );

      expect(stylusEvent.kind, equals(PointerDeviceKind.stylus));
    });
  });

  group('Pan Gesture Configuration', () {
    test('can set onStart callback', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      var startCalled = false;
      recognizer.onStart = (_) {
        startCalled = true;
      };

      expect(recognizer.onStart, isNotNull);
      expect(startCalled, isFalse);
    });

    test('can set onUpdate callback', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      var updateCalled = false;
      recognizer.onUpdate = (_) {
        updateCalled = true;
      };

      expect(recognizer.onUpdate, isNotNull);
      expect(updateCalled, isFalse);
    });

    test('can set onEnd callback', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      var endCalled = false;
      recognizer.onEnd = (_) {
        endCalled = true;
      };

      expect(recognizer.onEnd, isNotNull);
      expect(endCalled, isFalse);
    });

    test('can set onCancel callback', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      var cancelCalled = false;
      recognizer.onCancel = () => cancelCalled = true;

      expect(recognizer.onCancel, isNotNull);
      expect(cancelCalled, isFalse);
    });

    test('inherits drag start behavior from PanGestureRecognizer', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // Default behavior is DragStartBehavior.start
      expect(recognizer.dragStartBehavior, equals(DragStartBehavior.start));

      recognizer.dragStartBehavior = DragStartBehavior.down;

      expect(recognizer.dragStartBehavior, equals(DragStartBehavior.down));
    });

    test('can configure min fling distance', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // Inherited from DragGestureRecognizer
      recognizer.minFlingDistance = 50.0;

      expect(recognizer.minFlingDistance, equals(50.0));
    });

    test('can configure min fling velocity', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      recognizer.minFlingVelocity = 100.0;

      expect(recognizer.minFlingVelocity, equals(100.0));
    });

    test('can configure max fling velocity', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      recognizer.maxFlingVelocity = 5000.0;

      expect(recognizer.maxFlingVelocity, equals(5000.0));
    });

    test('inherits gesture settings configuration', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // Should be able to access gestureSettings
      expect(() => recognizer.gestureSettings, returnsNormally);
    });
  });

  group('Recognizer Lifecycle', () {
    test('dispose can be called without error', () {
      final recognizer = NonTrackpadPanGestureRecognizer();

      expect(() => recognizer.dispose(), returnsNormally);
    });

    test('dispose can be called after setting callbacks', () {
      final recognizer = NonTrackpadPanGestureRecognizer();

      recognizer.onStart = (_) {};
      recognizer.onUpdate = (_) {};
      recognizer.onEnd = (_) {};
      recognizer.onCancel = () {};

      expect(() => recognizer.dispose(), returnsNormally);
    });

    test('multiple recognizers can exist simultaneously', () {
      final recognizer1 = NonTrackpadPanGestureRecognizer(debugOwner: 'Owner1');
      final recognizer2 = NonTrackpadPanGestureRecognizer(debugOwner: 'Owner2');

      expect(recognizer1.debugOwner, equals('Owner1'));
      expect(recognizer2.debugOwner, equals('Owner2'));

      recognizer1.dispose();
      recognizer2.dispose();
    });
  });

  group('PointerPanZoom Event Filtering', () {
    test('PointerPanZoomStartEvent has trackpad kind by default', () {
      final event = PointerPanZoomStartEvent(
        pointer: 1,
        position: const Offset(100, 100),
      );

      expect(event.kind, equals(PointerDeviceKind.trackpad));
    });

    test('PointerPanZoomUpdateEvent has trackpad kind by default', () {
      final event = PointerPanZoomUpdateEvent(
        pointer: 1,
        position: const Offset(100, 100),
        pan: Offset.zero,
        panDelta: Offset.zero,
        scale: 1.0,
        rotation: 0.0,
      );

      expect(event.kind, equals(PointerDeviceKind.trackpad));
    });

    test('PointerPanZoomEndEvent has trackpad kind by default', () {
      final event = PointerPanZoomEndEvent(
        pointer: 1,
        position: const Offset(100, 100),
      );

      expect(event.kind, equals(PointerDeviceKind.trackpad));
    });

    test('recognizer handles PointerPanZoomEndEvent without error', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final endEvent = PointerPanZoomEndEvent(
        pointer: 1,
        position: const Offset(100, 100),
      );

      expect(() => recognizer.handleEvent(endEvent), returnsNormally);
    });
  });

  group('Debug Description', () {
    test('recognizer has debug description from parent', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // The recognizer should have inherited debug description capabilities
      expect(
        recognizer.toString(),
        contains('NonTrackpadPanGestureRecognizer'),
      );
    });

    test('debug owner appears in debug representation', () {
      const owner = 'TestWidget';
      final recognizer = NonTrackpadPanGestureRecognizer(debugOwner: owner);
      addTearDown(recognizer.dispose);

      // The debug owner should be accessible
      expect(recognizer.debugOwner, equals(owner));
    });
  });

  group('Event Kind Verification', () {
    test('mouse events have correct device kind', () {
      final mouseDown = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.mouse,
      );

      final mouseMove = PointerMoveEvent(
        pointer: 1,
        position: const Offset(150, 150),
        delta: const Offset(50, 50),
        kind: PointerDeviceKind.mouse,
      );

      final mouseUp = PointerUpEvent(
        pointer: 1,
        position: const Offset(150, 150),
        kind: PointerDeviceKind.mouse,
      );

      expect(mouseDown.kind, equals(PointerDeviceKind.mouse));
      expect(mouseMove.kind, equals(PointerDeviceKind.mouse));
      expect(mouseUp.kind, equals(PointerDeviceKind.mouse));
    });

    test('touch events have correct device kind', () {
      final touchDown = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.touch,
      );

      expect(touchDown.kind, equals(PointerDeviceKind.touch));
    });

    test('stylus events have correct device kind', () {
      final stylusDown = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.stylus,
      );

      expect(stylusDown.kind, equals(PointerDeviceKind.stylus));
    });

    test('inverted stylus events have correct device kind', () {
      final invertedStylusDown = PointerDownEvent(
        pointer: 1,
        position: const Offset(100, 100),
        kind: PointerDeviceKind.invertedStylus,
      );

      expect(invertedStylusDown.kind, equals(PointerDeviceKind.invertedStylus));
    });
  });

  group('Trackpad Event Sequence Filtering', () {
    test('recognizer ignores complete trackpad pan/zoom sequence', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // Simulate a complete trackpad gesture sequence
      final startEvent = PointerPanZoomStartEvent(
        pointer: 1,
        position: const Offset(100, 100),
      );

      final updateEvent = PointerPanZoomUpdateEvent(
        pointer: 1,
        position: const Offset(100, 100),
        pan: const Offset(50, 50),
        panDelta: const Offset(10, 10),
        scale: 1.0,
        rotation: 0.0,
      );

      final endEvent = PointerPanZoomEndEvent(
        pointer: 1,
        position: const Offset(100, 100),
      );

      // All trackpad events should be handled without error
      // and should not trigger any pan callbacks
      var panStartCalled = false;
      var panUpdateCalled = false;
      var panEndCalled = false;

      recognizer.onStart = (_) => panStartCalled = true;
      recognizer.onUpdate = (_) => panUpdateCalled = true;
      recognizer.onEnd = (_) => panEndCalled = true;

      expect(() => recognizer.addPointerPanZoom(startEvent), returnsNormally);
      expect(() => recognizer.handleEvent(updateEvent), returnsNormally);
      expect(() => recognizer.handleEvent(endEvent), returnsNormally);

      // Pan callbacks should not be triggered by trackpad events
      expect(panStartCalled, isFalse);
      expect(panUpdateCalled, isFalse);
      expect(panEndCalled, isFalse);
    });
  });

  group('Edge Cases', () {
    test('handles events at origin position', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final event = PointerPanZoomStartEvent(pointer: 1, position: Offset.zero);

      expect(() => recognizer.addPointerPanZoom(event), returnsNormally);
    });

    test('handles events at large coordinates', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final event = PointerPanZoomStartEvent(
        pointer: 1,
        position: const Offset(10000, 10000),
      );

      expect(() => recognizer.addPointerPanZoom(event), returnsNormally);
    });

    test('handles events at negative coordinates', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      final event = PointerPanZoomStartEvent(
        pointer: 1,
        position: const Offset(-100, -100),
      );

      expect(() => recognizer.addPointerPanZoom(event), returnsNormally);
    });

    test('handles multiple pointers', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      for (var i = 0; i < 5; i++) {
        final event = PointerPanZoomStartEvent(
          pointer: i,
          position: Offset(i * 100.0, i * 100.0),
        );

        expect(() => recognizer.addPointerPanZoom(event), returnsNormally);
      }
    });
  });

  group('Inherited Behavior Verification', () {
    test('supports velocity tracking', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // VelocityTracker is created internally by PanGestureRecognizer
      // We verify the recognizer accepts velocity-related configuration
      expect(recognizer.velocityTrackerBuilder, isNotNull);
    });

    test('supports allowed button masks from DragGestureRecognizer', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // PanGestureRecognizer accepts both primary and secondary buttons
      // by default in newer Flutter versions
      expect(() => recognizer.supportedDevices, returnsNormally);
    });

    test('team membership works correctly', () {
      final recognizer = NonTrackpadPanGestureRecognizer();
      addTearDown(recognizer.dispose);

      // GestureRecognizer should support team configuration
      expect(recognizer.team, isNull);
    });
  });
}
